import datetime as dt

# Хочется отметить соблюдение длины строк и интервалов при объявлении
# классов и методов


class Record:
    def __init__(self, amount, comment, date=''):
        self.amount = amount
        self.date = (
            # при использовании тернарного оператора if лучше
            # закладывать простую логику, но если используете, то
            # корректнее было бы оставить if not date в одной строке,
            # else в следующей
            dt.datetime.now().date() if
            not
            date else dt.datetime.strptime(date, '%d.%m.%Y').date())
        self.comment = comment


# Общий комментарий - отсутствие докстрингов, рекомендуется при
# объявлении классов и методов оформлять в конструкции из тройных
# ковычек с большой буквы краткое описание, что это
# за сущность или что этот метод делает
class Calculator:
    def __init__(self, limit):
        self.limit = limit
        self.records = []

    # В следующей строке (как и по возможности в любых объявлениях
    # аргументов) рекомендуется использовать аннотацию типов, чтобы
    # дать явно понять, что метод add_record принимает record как
    # экземпляр класса Record, используя конструкцию
    # def add_record(self, record: Record)
    def add_record(self, record):
        self.records.append(record)

    def get_today_stats(self):
        # при вызове метода мы каждый раз обнуляем today_stats,
        # вероятно есть подразумевается что today_stats мы будем
        # откуда-то получать и затем суммировать с Record.amount
        today_stats = 0
        # переменную в цикле не рекомендуется писать с большой буквы
        for Record in self.records:
            # dt.datetime.now().date() применяется несколько раз в
            # логике класса, можно вынести в отдельный аттрибут

            if Record.date == dt.datetime.now().date():
                today_stats = today_stats + Record.amount
        return today_stats

    def get_week_stats(self):
        week_stats = 0
        today = dt.datetime.now().date()
        for record in self.records:
            if (
                # тут применяется цепное сравнение, в Python его можно и
                # рекомендуется упрощать, например тут можно использовать
                # if 7 > (today - record.date).days >= 0:
                (today - record.date).days < 7 and
                (today - record.date).days >= 0
            ):
                # в методе get_today_stats использовалась конструкция
                # today_stats = today_stats + Record.amount, здесь же
                # используется оператор +=, логика задействована одна
                # и та же, но нарушается консистентность методов решения
                # одинаковых проблем
                week_stats += record.amount
        return week_stats


class CaloriesCalculator(Calculator):
    def get_calories_remained(self):  # Получает остаток калорий на сегодня
        # Не рекомендуется использовать однобуквенные переменные нигде,
        # кроме циклов (например for i in range()). Использование
        # однобквенных переменных делает код менее читаемым и понятным
        x = self.limit - self.get_today_stats()
        if x > 0:
            # Не рекомендуется использовать '\' для переносов строки.
            # Чтобы не использовать бэкслеш для переноса достаточно
            # обернуть выражение в круглые скобки
            # Также отступы должны быть кратны 4м пробелам
            # Чтобы не ошибиться имеет смысл использовать табуляцию
            # клавишей TAB
            return f'Сегодня можно съесть что-нибудь' \ 
                   f' ещё, но с общей калорийностью не более {x} кКал'
        else:
            # А тут нет необходимости в круглых скобках, каких-либо
            # логических операций или переносов строки не используется
            # Также после return рекомендуется ставить пробел
            return('Хватит есть!')


class CashCalculator(Calculator):
    # Скорее комментарий по логике, имеет смысл вынести курсы валют
    # в отдельный класс с перечислением возможных валют и логикой
    # получения их курсов
    USD_RATE = float(60)  # Курс доллар США.
    EURO_RATE = float(70)  # Курс Евро.

    # Объявление констант заглавными буквами правильное, но при
    # определении функции, аргументы лучше задать строчными буквами,
    # используя конструкцию usd_rate = USD_RATE
    def get_today_cash_remained(self, currency,
                                USD_RATE=USD_RATE, EURO_RATE=EURO_RATE):
        # Тут нет необходимости переназначать переменную,
        # при проверке валюты можно использовать currency
        currency_type = currency
        cash_remained = self.limit - self.get_today_stats()
        # Тут в некоторых проверках используется currency, в некоторых
        # currency_type, которые по логике выше повторяют друг друга
        # Рекомендую не использовать currency_type
        if currency == 'usd':
            cash_remained /= USD_RATE
            currency_type = 'USD'
        elif currency_type == 'eur':
            cash_remained /= EURO_RATE
            currency_type = 'Euro'
        elif currency_type == 'rub':
            # В следующей строке используется оператор сравнения "=="
            # Скорее всего подразумевалось умножение на 1, тк не
            # производится корректировка на курс, тогда используется
            # '*='. Но в данном случае операция умножения
            # на 1 не несет дополнительной логики, поэтому можно просто
            # не использовать следуюущую строку
            cash_remained == 1.00
            currency_type = 'руб'
        if cash_remained > 0:
            return (
                # Не рекомендуется использовать дополнительную логику
                # внутри переменных f строк, лучше провести округление
                # отдельно
                f'На сегодня осталось {round(cash_remained, 2)} '
                f'{currency_type}'
            )
        elif cash_remained == 0:
            return 'Денег нет, держись'
        # Конструкции if не заканчивается else: лучше стремиться
        # указывать все возможные варианты поведения сравнений, например
        # если cash_remained будет None, то мы в эти сравнения даже не
        # попадём
        elif cash_remained < 0:
            # Здесь также нарушается консистетность методов решения
            # одинаковых задач, выше по коду используется f-строка,
            # тут используется метод .format
            # Метод .format рекомендуется использовать в случаях, когда
            # строка приходит откуда-то из внешних источников
            # Также и здесь не рекомендуется использовать дополнительную
            # логку в форматировании строки в части переменной
            # -cash_remained
            return 'Денег нет, держись:' \
                   ' твой долг - {0:.2f} {1}'.format(-cash_remained,
                                                     currency_type)

    # При наследовании класса дочерний класс наследует от родителя
    # все аттрибуты и методы. В данном случае если мы хотим
    # использовать логику метода get_week_stats() в дочернем
    # классе CashCalculator, то нам нет необходимости его
    # переопределять, он уже будет доступен для использования
    def get_week_stats(self):
        super().get_week_stats()
# В конце python файла рекомендуется всегда оставлять пустую строку
# Раньше отсутствие пустой строки вызывало ошибки интерпретатора

# Если планируете запускать модуль отдельно, то в конце исполняемых
# файлов необходима конструкция if __name__ == '__main__', в которой
# можно описать логику при запуске модуля.
